<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串匹配——暴力匹配与KMP</title>
      <link href="%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E5%92%8CKMP%E7%AE%97%E6%B3%95/"/>
      <url>%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E5%92%8CKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>leetcode题库28题要求实现c语言库函数<code>strStr()</code>，这就是纯粹的字符串匹配问题。正好复习一下数据结构里面学到的KMP算法。对于KMP的优化，书上是向前迭代一次<code>next[]</code>，我的实现是迭代到不能再迭代。其实大多时候，暴力匹配足够香。</p><a id="more"></a><h3 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h3><p>从下标为0开始，逐个比较模式串和和目标串的每个字符。若出现不匹配情况，则置目标串的下标为1，模式串的下标为0，继续匹配……直到匹配成功或遍历到目标串的尾端。思路简单，并且由于<code>subString()</code>方法的存在，实现起来就更简单了。直接比较截取的字符串和模式串是否相等。注意<code>equals()</code>的底层实现，对于<code>String</code>的比较，仍然是一位一位对比，效率和逐个比较<code>char</code>是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标串为haystack，模式串为needle</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr2</span><span class="params">(String haystack, String needle)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果needle为空，匹配的位置自然是0</span></span><br><span class="line">        <span class="keyword">if</span>(needle.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nLength = needle.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;haystack.length()-nLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.substring(i, i+nLength).equals(needle))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>花了不少时间，KMP算法总算是明白一二了。按我的理解阐述一下KMP算法。</p><p><a href="https://imgchr.com/i/B0shKe"><img src="https://s1.ax1x.com/2020/11/01/B0shKe.png" alt="B0shKe.png"></a></p><p>如上图所示，上面是目标串，下面是模式串。i和j初值均为0开始匹配。当i和j分别到达图示位置时，匹配失败。按照暴力匹配思想，i应该回退至1，j回退至0。实际上，在下一次i到达图示位置前，匹配过程是串<code>aba</code>自身的后端和前端的匹配。先是模式串右移一位，ba和ab匹配，失败。再右移一位，模式串到了图示最下面的状态，a和a匹配，成功。这时候i才重回图示位置。如果我们能够提前把模式串的前n位的首尾匹配字符数量计算出来，那么i就不用回退，j也不是每次都从0开始匹配。</p><p>这就诞生了<strong>数组next</strong>的定义。<code>next</code>数组长度和模式串长度相等。若<code>next[i]=k</code>，则表示模式串前<code>i+1</code>位字符串的前k位和后k位匹配，并且这个k是最大的，但不能是<code>i+1</code>，也就是不能把自身算进去。有了<code>next</code>数组，对于上面所述情形，i不需要回退，j回退到<code>next[j-1]</code>，继续匹配。</p><p>如何<strong>计算<code>next</code>数组</strong>？假设字符串对应的数组是<code>chars[]</code>，显然<code>next[0]</code>等于0。我们能够感觉到<code>next</code>数组的相邻项之间存在着迭代关系。对于第i项：</p><p>假设<code>next[i-1]=k</code>，表示字符串第0位至第k-1位这k位和第i位的前k位相同。那么，如果<code>char[i]==char[k]</code>，有<code>next[i]=k+1</code>。如果<code>char[i]!=char[k]</code>，说明<code>next[i]</code>必定小于k，那么只能从第k位之前寻找首尾相等的最大数值，而这个数量我们已经有了定义：<code>next[k-1]</code>。那么，令<code>k=next[k-1]</code>，再去判断<code>char[i]</code>和<code>char[k]</code>是否相等，也就是重复上面过程，直到<code>char[i]==char[k]</code>。如果一直不相等，即k迭代到了0，并且<code>char[0]!=char[i]</code>，那么说明前i位的首尾没有完全匹配的可能，则<code>next[i]=0</code>。代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String pattern)&#123;</span><br><span class="line">        <span class="keyword">int</span> length = pattern.length();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = next[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(k&gt;<span class="number">0</span> &amp;&amp; pattern.charAt(i)!=pattern.charAt(k))</span><br><span class="line">                k = next[k-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(pattern.charAt(i) == pattern.charAt(k))</span><br><span class="line">                k++;</span><br><span class="line">            next[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有了<code>next</code>数组，那么模式串和目标串的匹配就简单了一些。目标串的指针j不再需要回溯，遇到某个字符不匹配，模式串的指针置<code>next[i-1]</code>就可以了，如果i回到了第0位仍然不匹配，就需要移进j指针了。匹配过程的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(needle);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;haystack.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(j) != needle.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = next[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(i==needle.length())</span><br><span class="line">                    <span class="keyword">return</span> j-needle.length();</span><br><span class="line">                <span class="keyword">if</span>(j==haystack.length())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法优化"><a href="#KMP算法优化" class="headerlink" title="KMP算法优化"></a>KMP算法优化</h3><p>我们注意到，在匹配的迭代过程中，还是会出现冗余的匹配。如下图：</p><p><a href="https://imgchr.com/i/B0sOxS"><img src="https://s1.ax1x.com/2020/11/01/B0sOxS.png" alt="B0sOxS.png"></a></p><p>前三个字符都是a，所以当第一次b和a出现不匹配时，就没有必要比较其他前面的a了。我们得出的<code>next[i]=k</code>，有第k位字符<code>pattern.charAt(k-1)</code>与第i位字符<code>pattern.charAt(i)</code>相等，所以当模式串第i位和目标串不匹配时，回退到第<code>next[i-1]</code>位，若该位字符和第i位相同，那么就没必要进行此次比较，我们可以直接回退到<code>next[next[i-1]-1]</code>位。此过程可以迭代。</p><p>由此我们引出<code>nextval[]</code>数组的定义，<code>nextval[i]</code>表示若<code>pattern.charAt(i)</code>不匹配的回退位置，该位置由<code>next[]</code>数组根据上面的迭代得到。由<code>next[]</code>求<code>nextval</code>的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNextval(String pattern, <span class="keyword">int</span> next[])&#123;</span><br><span class="line">        <span class="keyword">int</span> length = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] nextval = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        nextval[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; pattern.charAt(next[j-<span class="number">1</span>]) == pattern.charAt(j)) &#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    next[i-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    next[i-<span class="number">1</span>] = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nextval[i] = next[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextval;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应于<code>nextval[]</code>下的KMP匹配，只需要把原代码中的<code>next</code>数组替换为<code>nextval</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">optimizedKMP</span><span class="params">(String haystack, String needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nextval = getNextval(needle, getNext(needle));</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;haystack.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(j) != needle.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span> i = nextval[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(i==needle.length())</span><br><span class="line">                    <span class="keyword">return</span> j-needle.length();</span><br><span class="line">                <span class="keyword">if</span>(j==haystack.length())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优化的KMP对于模式串存在大量连续重复的字母有着速度的提升，但这种提升在目标串长度足够长时才能够很好的体现。而一般的KMP算法，基本大部分时候效率都低于暴力算法。暴力更便捷的原因在于没有<code>next[]</code>的计算。</p><p>后记：</p><p>写完代码发现，网上代码对于<code>next[i]</code>表示的是第0位至第i-1位的求解，而我的代码是第0位至第i位。不过这无伤大雅，重要的是思路。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题库17-20总结</title>
      <link href="leetcode%E9%A2%9817-20%E6%80%BB%E7%BB%93/"/>
      <url>leetcode%E9%A2%9817-20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>翻了一下leetcode，前16道题除了困难等级外都在去年寒假时候解决了，后来也没有坚持刷题。都大三了，该有点自知之明了。从现在开始每天至少一道leetcode，此系列博文为见证。</p><a id="more"></a><h3 id="十七-电话号码的字母组合"><a href="#十七-电话号码的字母组合" class="headerlink" title="十七 电话号码的字母组合"></a>十七 电话号码的字母组合</h3><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目直达</a></p><blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p></blockquote><p><em>思路：</em></p><p>每个字母映射到3或4个字母。给出数字串，我们可以确定的信息是：每个字母组合的长度，即数字串的长度；总共可能的字母组合个数，即各位数字能够映射的字母数量之积<code>num</code>。所以，<code>0</code>到<code>num-1</code>的每个数字均对应一个字母组合。把每个十进制数转换为特殊进制（三进制和四进制的结合体），获得每一位上的数字，即可得到每位上对应的是哪个字符。这样一趟循环就可以得到所有字母组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Two;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Three;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Four;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Five;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Six;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Seven;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Eight;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Character&gt; Nine;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//数字、字母对应关系初始化</span></span><br><span class="line">        Two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Two, <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        Three = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Three,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">        Four = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Four,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">        Five = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Five,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        Six = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Six,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">        Seven = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Seven,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        Eight = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Eight,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>);</span><br><span class="line">        Nine = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(Nine,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> stringLength = digits.length();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Character&gt;&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; carry = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stringLength;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> index = digits.charAt(i);</span><br><span class="line">            <span class="keyword">switch</span> (index)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">3</span>;</span><br><span class="line">                    carry.add(<span class="number">3</span>);</span><br><span class="line">                    data.add(Two);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">3</span>;</span><br><span class="line">                    carry.add(<span class="number">3</span>);</span><br><span class="line">                    data.add(Three);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">3</span>;</span><br><span class="line">                    carry.add(<span class="number">3</span>);</span><br><span class="line">                    data.add(Four);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">3</span>;</span><br><span class="line">                    carry.add(<span class="number">3</span>);</span><br><span class="line">                    data.add(Five);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">3</span>;</span><br><span class="line">                    carry.add(<span class="number">3</span>);</span><br><span class="line">                    data.add(Six);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">4</span>;</span><br><span class="line">                    carry.add(<span class="number">4</span>);</span><br><span class="line">                    data.add(Seven);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">3</span>;</span><br><span class="line">                    carry.add(<span class="number">3</span>);</span><br><span class="line">                    data.add(Eight);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                    num*=<span class="number">4</span>;</span><br><span class="line">                    carry.add(<span class="number">4</span>);</span><br><span class="line">                    data.add(Nine);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">//十进制转换为特殊进制，算出每一位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;stringLength;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> carrying = carry.get(j);</span><br><span class="line">                <span class="keyword">int</span> index = temp % carrying;</span><br><span class="line">                temp /= carrying;</span><br><span class="line">                buffer.append(data.get(j).get(index));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(buffer.toString());</span><br><span class="line"><span class="comment">//            System.out.println(buffer.toString());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十八-四数之和"><a href="#十八-四数之和" class="headerlink" title="十八 四数之和"></a>十八 四数之和</h3><p><a href="https://leetcode-cn.com/problems/4sum/">题目直达</a></p><blockquote><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且<strong>不重复</strong>的四元组。</p></blockquote><p><em>思路：</em></p><p>第一步，排序。数组问题往往排序后能够更加清晰地解决。在此题之前已经做过两数之和以及三数之和的题目，仍然可以用相同的套路：指针扫描。两数之和求解：首尾指针往中间扫描，和小于或等于target，首指针后移，否则尾指针前移。遇到重复数字直接向前跳过，这样就解决了不重复的问题。三数之和在此基础上外层嵌套从0到倒数第三个元素的<code>for</code>循环即可，循环体内部构成一个两数之和求解。四数之和，在三数之和外层再套一层循环即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumThree = target-nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> y=nums.length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> sumTwo = sumThree-nums[j];</span><br><span class="line">                <span class="keyword">while</span> (x&lt;y)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[x]+nums[y];</span><br><span class="line">                    <span class="keyword">if</span>(temp==sumTwo)&#123;</span><br><span class="line">                        List&lt;Integer&gt; item = Arrays.asList(nums[i],nums[j],nums[x],nums[y]);</span><br><span class="line">                        result.add(item);</span><br><span class="line">                        <span class="keyword">while</span> (x&lt;y &amp;&amp; nums[x]==nums[x+<span class="number">1</span>]) x++;</span><br><span class="line">                        <span class="keyword">while</span> (x&lt;y &amp;&amp; nums[y]==nums[y-<span class="number">1</span>]) y--;</span><br><span class="line">                        x++;</span><br><span class="line">                        y--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp&lt;sumTwo)&#123;</span><br><span class="line">                        <span class="keyword">while</span> (x&lt;y &amp;&amp; nums[x]==nums[x+<span class="number">1</span>]) x++;</span><br><span class="line">                        x++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (x&lt;y &amp;&amp; nums[y]==nums[y-<span class="number">1</span>]) y--;</span><br><span class="line">                        y--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (j&lt;nums.length-<span class="number">2</span> &amp;&amp; nums[j]==nums[j+<span class="number">1</span>])</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;nums.length-<span class="number">1</span> &amp;&amp; nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十九-删除链表的倒数第N个节点"><a href="#十九-删除链表的倒数第N个节点" class="headerlink" title="十九 删除链表的倒数第N个节点"></a>十九 删除链表的倒数第N个节点</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">题目直达</a></p><blockquote><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p></blockquote><p><em>思路：</em></p><p>本题比较简单，但是需要考虑一些细节。在<code>java</code>中，对于单链表，直接使用<code>lastNode.next = node.next</code>即可消除对<code>node</code>的引用，<code>node</code>也就自动被回收。需要注意的是头节点没有前驱节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode headNode = head;</span><br><span class="line">        List&lt;ListNode&gt; pointers= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pointers.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = pointers.size();</span><br><span class="line">        <span class="keyword">if</span>(n==length)&#123;</span><br><span class="line">            headNode = headNode.next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            pointers.get(length-n-<span class="number">1</span>).next = pointers.get(length-n).next;</span><br><span class="line">        <span class="keyword">return</span> headNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二十-有效的括号"><a href="#二十-有效的括号" class="headerlink" title="二十 有效的括号"></a>二十 有效的括号</h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">题目直达</a></p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p></blockquote><p><em>思路：</em></p><p>括号匹配是需要匹配最近的一个括号，后进的先匹配，所以一下就想到了栈。但是如果用三个栈分别处理三种括号，那么类似于<code>[&#123;]&#125;</code>的字符串也会被认为是有效的。所以需要巧妙的利用一个栈来进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            c = s.charAt(i);</span><br><span class="line">            <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:stack.push(<span class="string">&#x27;)&#x27;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:stack.push(<span class="string">&#x27;&#125;&#x27;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:stack.push(<span class="string">&#x27;]&#x27;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.empty() || c!=stack.pop())</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后可直接替换为 return stack.empty();</span></span><br><span class="line">        <span class="keyword">if</span>(!stack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码题库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE基础：集合框架</title>
      <link href="JAVA%20SE%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>JAVA%20SE%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p><code>Java</code>提供的集合框架是高性能的，并且扩展性强。主要包括两种类型的容器，集合<code>Collection</code>和图<code>Map</code>。</p><a id="more"></a><h3 id="Collection—集合"><a href="#Collection—集合" class="headerlink" title="Collection—集合"></a>Collection—集合</h3><p><code>Collection</code>是最基本的集合接口，在<code>Collection</code>中定义了一些通用方法，可用于所有<code>Collection</code>的实现类：</p><ul><li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> ：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li><li><code>public int size()</code>：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中。</li></ul><p>它主要有<code>list</code>和<code>set</code>两个子接口。</p><ul><li><code>List</code>：有序集合，存储元素可重复。类比于数组，可动态扩充。常用方法：</li></ul><ul><li><code>public E get(int index)</code>：返回指定位置的元素<ul><li><code>public E remove(int index)</code>：移除指定位置元素并返回</li><li><code>public E set(int index, E element)</code>：指定元素替换，返回替换前的元素。</li></ul></li></ul><p>几个常用的实现类如下：</p><ul><li><p><code>ArrayList</code>：随机访问和遍历性能好，删除和插入效率低。非同步，<strong>多线程不安全</strong>。</p></li><li><p><code>LinkedList</code>：一个双链表。没有同步方法，多线程访问需要自己实现同步。方便元素删除和添加。使用<code>addFirst(E e)</code>和<code>getFirst()</code>方法可以快速操作开头元素。同样的结尾元素也有get和set方法。</p></li><li><p><code>Set</code>：无序集合，存储元素不可重复。检索效率低，删除和插入效率高。几个常用的实现类：</p><ul><li><code>HashSet</code>：根据元素的哈希值来确定元素在集合中的存储位置，性能良好。元素唯一性依赖于<code>hashcode()</code>和<code>equals()</code>方法。存储自定义类型时，需要重写这两个方法。哈希表底层实现：数据+链表+红黑树。</li><li><code>LinkedHashSet</code>：<code>HashSet</code>的继承类，链表+哈希表组合的数据结构，使得存储的元素有了顺序。</li></ul></li></ul><h3 id="Iterator—迭代器"><a href="#Iterator—迭代器" class="headerlink" title="Iterator—迭代器"></a>Iterator—迭代器</h3><p><code>Java</code>针对集合的遍历提供了接口<code>java.util.Iterator</code>。取元素前判断集合是否为空，如果有元素就取出来，直到把所有元素全部取出。常用方法：</p><ul><li><code>public E next()</code>：返回下一个迭代元素。</li><li><code>public boolean hasNext()</code>：如果仍有元素可以迭代，则返回 true。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设已有存储String的ArrayList变量list</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<code>foreach</code>也可用于遍历集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具类—Collections"><a href="#工具类—Collections" class="headerlink" title="工具类—Collections"></a>工具类—Collections</h3><p><code>Collections</code>是集合工具类，定义了一些针对集合的实用方法。如：</p><ul><li><code>public static &lt;T&gt; boolean addall(Collection&lt;T&gt; c, T... elements)</code>：方便地向集合中添加多个元素。</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>：shuffle英文释义有洗牌的意思，该方法用于打乱集合顺序。</li><li><code>public staic &lt;T&gt; void sort(List&lt;T&gt; list)</code>：按默认规则将集合排序。</li><li><code>public staic &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; )</code>：按指定规则将集合排序。</li></ul><p>自定义<code>Comparator</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按字符串首字母降序排列。</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>是专门用于存储由键值对的集合，它不是<code>Collection</code>的子接口。每个键对应一个值，键不能重复。<code>Map</code>接口的常用方法：</p><ul><li><code>public V put(K key，V value)</code>：把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>：把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code>：根据指定的键，在Map集合中获取对应的值。</li><li><code>public Set&lt;K&gt; keySet()</code>：获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取到Map集合中所有的键值对对象的集合。<code>Entry</code>将键值对封装为了对象，这样我们可以先通过<code>entrySet()</code>方法获取到键值对集合，通过得到的<code>Entry</code>对象遍历Map。</li></ul><p>常用子类：</p><ul><li><code>HashMap</code>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的<code>hashCode()</code>方法、<code>equals()</code>方法。</li><li><code>LinkedHashMap</code>：<code>HashMap</code>的子类，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的<code>hashCode()</code>方法、<code>equals()</code>方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
